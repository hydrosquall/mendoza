# Mendoza patch format
:toc:

A Mendoza patch consists of a list of _operations_ which are executed, very much like a virtual machine.

## Execution model

Applying a patch involves executing the operations while maintaining the following state:

- The left document.
- An _input stack_, used for traversing the left document.
- An _output stack_, used for producing the right document. Every entry of the output stack also stores the _key_ where it came from.

We also define the following terms:

- The _input value_ is the value at the top of the input stack.
- The _output value_ is the value at the top of the output stack.

## Examples / tutorial

Here are some examples which also serves as a mini tutorial.

### Starting from scratch vs. starting with copy

Sometimes it's better to start with a blank object and copy over the fields you need:

- `Enter(Root, Object)`
- `CopyField("name")`
- `SetFieldValue("age", 30)`

â€¦ while other times it's better to start with a copy and delete the fields you don't need:

- `Enter(Root, Copy)`
- `DeleteField("skills")`
- `SetFieldValue("age", 30)`

### Entering fields

The `Enter` operation is usd for entering fields in objects:

- `Enter(Root, Copy)`
- `Enter(Field("user"), Copy)`
- `Enter(Field("address"), Copy)`
- `SetFieldValue("zip", 1234)`
- `Return()`
- `Return()`

Note that entering a field remembers the key where it come from, which `Return()` then uses to set it.

### Renaming a field

Renaming a field is done by entering and then returning with a different key:

- `Enter(Root, Copy)`
- `Enter(Field("user"), Copy)`
- `Return("userDetails")`

### Dealing with arrays

Arrays are typically dealt with by entering with a blank array and then using `AppendSlice` and `AppendValue`:

- `Enter(Root, Copy)`
- `Enter(Field("skills"), Array)`
- `AppendSlice(0, 2)`
- `AppendValue("Go")`
- `Return()`


### Complete patch

The following patch:

- `Enter(Root, Copy)`
- `DeleteField("name")`
- `Enter(Field("name"), Copy)`
- `Return("fullName")`
- `Enter(Field("skills"), Array)`
- `AppendSlice(0, 2)`
- `AppendValue("Go")`
- `Return()`

Has the following semantics:

0. Push the left document onto the input stack, and a copy of it onto the output stack.
0. Delete the field `"name"` in the output value.
0. Copy the field `"name"` in the input value into onto the input and output stack.
0. Take the value of the field `"skills"`, push it onto the input stack and push an empty array onto the output stack.
0. Append the slice `[0:2]` from the input value to the output value.
0. Append the literal value `"Go"` to the output value.
0. Pop from both stacks and store the result at `"skills"`.

## List of operations

### `Enter` operation

.Params
- `source`: One of `Index(int)`, `Field(string)`, `Root`
- `output`: One of `Copy`, `Array`, `Object`, `Nop`

The `Enter` operation is used for accessing and modifying nested objects.
It executes in two steps:

.Step 1: Finding the new input value
- If `source` is `Index(int)`, it finds the new input value by looking up the element in the current input value array.
- If `source` is `Field(string)` it finds the new input value by looking up the field in the current input value object.
- If `source` is `Root`, then the new input value is the left document.

.Step 2: Finding the new output value
- If `output` is `Copy`, then the new output value is a copy of the new input value.
- If `output` is `Array`, then the new output value is an empty array.
- If `output` is `Object`, then the new output value is an empty object.
- If `output` is `Nop`, then there is no new output value.

After the new input/output value has been determined, it pushes them onto the stacks:
- The new input value is pushed onto the input stack.
- If there was a new output value, it's pushed onto the output stack together with information about the `source`.
  See the `Return` operation for how this is used.

### `Return` operation

.Params
- `key`: Optional `string`

The `Return` operation pops from both the input/output stack and stores the result in the new output value object.
More concretely:

- The input stack is popped.
- If the `key` is not present, then it's set to the field from the source stored in the top of the output stack.
- Let `fieldValue` be a copy of the current output value.
- The output stack is popped (thus the next value on the stack is now the output value).
- The field `key` in the output value object is set to `fieldValue`.

### `OutputValue` operation

.Params
- `value`

Pushes the value onto the output value stack.
This operation only makes sense as the first operation in a patch (when you want to represent).

### `SetFieldValue` operation

.Params
- `key`: `string`
- `value`

Sets the field `key` in the output value object to `value`.

### `CopyField` operation

.Params
- `key`: `string`

Copies the field named `key` from the input value object into the output value object.

[NOTE]
====
This is equivalent to:

- `Enter(Field(key))`
- `Return()`
====

### `DeleteField` operation

.Params
- `key`: `string`

Deletes the field named `key` in the output value object.

### `AppendValue` operation

.Params
- `value`

Appends the `value` to the output value array.

### `AppendSlice` operation

.Params
- `left`: `int`
- `right`: `int`

Takes the values stored between the indices `left` and `right` (exclusive) in the input value array and appends them to the output value array.

## JSON representation

TODO.